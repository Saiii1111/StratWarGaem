<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circle Battle: Player vs AI</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a2a6c, #2c3e50);
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        .header { text-align: center; margin-bottom: 20px; width: 100%; max-width: 800px; }
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: linear-gradient(to right, #3498db, #e74c3c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle { font-size: 1.2rem; margin-bottom: 20px; color: #ecf0f1; }
        .game-container {
            display: flex; flex-direction: column; align-items: center;
            background: rgba(0,0,0,0.7); border-radius: 15px; padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); max-width: 1000px; width: 95%;
        }
        .game-info { display: flex; justify-content: space-between; width: 100%; margin-bottom: 15px; padding: 0 10px; }
        .team-info { display: flex; gap: 20px; }
        .team { display: flex; align-items: center; gap: 10px; padding: 8px 15px; border-radius: 20px; font-weight: bold; }
        .player-team { background: rgba(52,152,219,0.3); border: 2px solid #3498db; }
        .ai-team { background: rgba(231,76,60,0.3); border: 2px solid #e74c3c; }
        .circle-indicator { width: 20px; height: 20px; border-radius: 50%; }
        .blue-circle { background-color: #3498db; box-shadow: 0 0 10px #3498db; }
        .red-circle { background-color: #e74c3c; box-shadow: 0 0 10px #e74c3c; }
        .controls { display: flex; gap: 15px; margin-bottom: 15px; flex-wrap: wrap; justify-content: center; }
        button {
            background: #3498db; color: white; border: none; padding: 10px 20px;
            border-radius: 5px; cursor: pointer; font-weight: bold; transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        button:hover { transform: translateY(-2px); box-shadow: 0 6px 8px rgba(0,0,0,0.4); }
        button:active { transform: translateY(1px); }
        #spawnBlue { background: #3498db; }
        #spawnRed { background: #e74c3c; }
        #spawnBlue:hover { background: #2980b9; }
        #spawnRed:hover { background: #c0392b; }
        #clearAll { background: #e67e22; }
        #clearAll:hover { background: #d35400; }
        canvas { background-color: #2c3e50; border-radius: 10px; box-shadow: 0 0 20px rgba(0,0,0,0.5); cursor: pointer; }
        .instructions { margin-top: 20px; text-align: center; max-width: 600px; line-height: 1.5; background: rgba(0,0,0,0.5); padding: 15px; border-radius: 10px; }
        .selected-info { margin-top: 10px; font-weight: bold; min-height: 24px; color: #f1c40f; }
        .game-stats { display: flex; justify-content: space-around; width: 100%; margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 10px; }
        .stat { text-align: center; }
        .stat-value { font-size: 1.5rem; font-weight: bold; color: #f1c40f; }
        .difficulty-controls { display: flex; gap: 10px; margin-top: 10px; }
        .difficulty-btn { padding: 5px 10px; font-size: 0.9rem; }
        .active-difficulty { background: #f1c40f; color: #2c3e50; }
        @media (max-width: 768px) {
            .game-info { flex-direction: column; align-items: center; gap: 10px; }
            .controls { flex-direction: column; width: 100%; }
            button { width: 100%; }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Circle Battle: Player vs AI</h1>
        <p class="subtitle">Control blue circles against AI-controlled red circles</p>
    </div>
    
    <div class="game-container">
        <div class="game-info">
            <div class="team-info">
                <div class="team player-team">
                    <div class="circle-indicator blue-circle"></div>
                    <span id="blueCount">0</span> Player Circles
                </div>
                <div class="team ai-team">
                    <div class="circle-indicator red-circle"></div>
                    <span id="redCount">0</span> AI Circles
                </div>
            </div>
            <div class="selected-info" id="selectedInfo"></div>
        </div>
        
        <div class="game-stats">
            <div class="stat">
                <div class="stat-value" id="playerKills">0</div>
                <div>Player Kills</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="aiKills">0</div>
                <div>AI Kills</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="gameTime">0</div>
                <div>Seconds</div>
            </div>
        </div>
        
        <div class="controls">
            <button id="spawnBlue">Spawn Player Circle</button>
            <button id="spawnRed">Spawn AI Circle</button>
            <button id="clearAll">Clear All</button>
        </div>
        
        <div class="difficulty-controls">
            <button id="easy" class="difficulty-btn">Easy</button>
            <button id="medium" class="difficulty-btn active-difficulty">Medium</button>
            <button id="hard" class="difficulty-btn">Hard</button>
        </div>
        
        <canvas id="gameCanvas" width="800" height="500"></canvas>
        
        <div class="instructions">
            <p><strong>How to Play:</strong> Click on a blue circle to select it (highlighted with a yellow border). 
            Click elsewhere to move the selected circle to that location. Blue circles (player) automatically attack red circles (AI) 
            on collision. Health bars show above each circle.</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const blueCountElement = document.getElementById('blueCount');
        const redCountElement = document.getElementById('redCount');
        const selectedInfoElement = document.getElementById('selectedInfo');
        const playerKillsElement = document.getElementById('playerKills');
        const aiKillsElement = document.getElementById('aiKills');
        const gameTimeElement = document.getElementById('gameTime');
        const spawnBlueButton = document.getElementById('spawnBlue');
        const spawnRedButton = document.getElementById('spawnRed');
        const clearAllButton = document.getElementById('clearAll');
        const difficultyButtons = {
            easy: document.getElementById('easy'),
            medium: document.getElementById('medium'),
            hard: document.getElementById('hard')
        };

        let circles = [];
        let selectedCircle = null;
        let playerKills = 0;
        let aiKills = 0;
        let gameTime = 0;
        let gameStartTime = Date.now();
        let difficulty = 'medium';

        class Circle {
            constructor(x, y, team) {
                this.x = x; this.y = y; this.team = team;
                this.radius = 20; this.maxHealth = 100; this.health = this.maxHealth;
                if (team === 'blue') { this.speed = 2.5; this.attackPower = 12; }
                else {
                    if (difficulty === 'easy') { this.speed = 1.5; this.attackPower = 8; }
                    else if (difficulty === 'medium') { this.speed = 2; this.attackPower = 10; }
                    else { this.speed = 2.2; this.attackPower = 12; }
                }
                this.targetX = null; this.targetY = null; this.isMoving = false;
                this.attackCooldown = 0;
                this.aiState = 'wander'; this.aiTarget = null;
                this.wanderDirection = Math.random() * Math.PI * 2;
                this.wanderChange = 0;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
                ctx.fillStyle = this.team === 'blue' ? '#3498db' : '#e74c3c';
                ctx.fill();
                if (this === selectedCircle) {
                    ctx.strokeStyle = '#f1c40f'; ctx.lineWidth = 3; ctx.stroke();
                }
                ctx.fillStyle = '#333';
                ctx.fillRect(this.x - 25, this.y - this.radius - 15, 50, 8);
                const healthPercent = this.health / this.maxHealth;
                ctx.fillStyle = healthPercent>0.6?'#2ecc71':healthPercent>0.3?'#f39c12':'#e74c3c';
                ctx.fillRect(this.x - 25, this.y - this.radius - 15, 50 * healthPercent, 8);
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.strokeRect(this.x - 25, this.y - this.radius - 15, 50, 8);
            }

            move() {
                if (this.team === 'blue') {
                    if (this.isMoving && this.targetX !== null && this.targetY !== null) {
                        const dx = this.targetX - this.x;
                        const dy = this.targetY - this.y;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        if (distance > this.speed) {
                            this.x += dx / distance * this.speed;
                            this.y += dy / distance * this.speed;
                        } else { this.x = this.targetX; this.y = this.targetY; this.isMoving = false; }
                    }
                } else { this.updateAI(); }
                if (this.attackCooldown>0) this.attackCooldown--;
            }

            updateAI() {
                let nearestPlayer = null; let nearestDistance = Infinity;
                for (const circle of circles) {
                    if (circle.team === 'blue') {
                        const dx = circle.x - this.x; const dy = circle.y - this.y;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        if (distance < nearestDistance) { nearestDistance = distance; nearestPlayer = circle; }
                    }
                }
                if (nearestPlayer) {
                    if (nearestDistance < 50) { 
                        this.aiState='attack'; this.aiTarget=nearestPlayer; this.targetX=null; this.targetY=null;
                        const dx = nearestPlayer.x - this.x; const dy = nearestPlayer.y - this.y;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        if (distance>0){ this.x+=dx/distance*this.speed*0.5; this.y+=dy/distance*this.speed*0.5; }
                    } else if (nearestDistance<200) {
                        this.aiState='chase'; this.aiTarget=nearestPlayer;
                        this.targetX = nearestPlayer.x; this.targetY = nearestPlayer.y;
                    } else { this.aiState='wander'; this.aiTarget=null; }
                } else { this.aiState='wander'; this.aiTarget=null; }

                if (this.aiState==='chase' && this.aiTarget) {
                    const dx = this.targetX - this.x; const dy = this.targetY - this.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    if (distance>this.speed){ this.x+=dx/distance*this.speed; this.y+=dy/distance*this.speed; }
                } else if (this.aiState==='wander') {
                    this.wanderChange--;
                    if (this.wanderChange<=0){ this.wanderDirection += (Math.random()-0.5)*Math.PI; this.wanderChange=30+Math.random()*30; }
                    this.x += Math.cos(this.wanderDirection) * this.speed * 0.7;
                    this.y += Math.sin(this.wanderDirection) * this.speed * 0.7;
                    if (this.x<this.radius){ this.x=this.radius; this.wanderDirection=Math.PI-this.wanderDirection; }
                    else if (this.x>canvas.width-this.radius){ this.x=canvas.width-this.radius; this.wanderDirection=Math.PI-this.wanderDirection; }
                    if (this.y<this.radius){ this.y=this.radius; this.wanderDirection=-this.wanderDirection; }
                    else if (this.y>canvas.height-this.radius){ this.y=canvas.height-this.radius; this.wanderDirection=-this.wanderDirection; }
                }
            }

            setTarget(x,y){ this.targetX=x; this.targetY=y; this.isMoving=true; }

            attack(enemy) {
                if (this.attackCooldown===0) {
                    enemy.health -= this.attackPower; this.attackCooldown=30;
                    ctx.beginPath(); ctx.moveTo(this.x,this.y); ctx.lineTo(enemy.x,enemy.y);
                    ctx.strokeStyle = this.team==='blue'?'#3498db':'#e74c3c'; ctx.lineWidth=2; ctx.stroke();
                    if (enemy.health<=0){
                        if (this.team==='blue'){ playerKills++; playerKillsElement.textContent=playerKills; }
                        else { aiKills++; aiKillsElement.textContent=aiKills; }
                    }
                    return true;
                }
                return false;
            }

            isCollidingWith(other){
                const dx=this.x-other.x; const dy=this.y-other.y;
                const distance=Math.sqrt(dx*dx + dy*dy);
                return distance<this.radius+other.radius;
            }
        }

        function init(){
            for(let i=0;i<5;i++){ spawnRandomCircle('blue'); spawnRandomCircle('red'); }
            gameLoop();
            updateCircleCounts();
            setInterval(()=>{ gameTime=Math.floor((Date.now()-gameStartTime)/1000); gameTimeElement.textContent=gameTime; },1000);
        }

        function spawnRandomCircle(team){
            const x = Math.random()*(canvas.width-40)+20;
            const y = Math.random()*(canvas.height-40)+20;
            circles.push(new Circle(x,y,team)); updateCircleCounts();
        }

        function updateCircleCounts(){
            blueCountElement.textContent = circles.filter(c=>c.team==='blue').length;
            redCountElement.textContent = circles.filter(c=>c.team==='red').length;
        }

        function clearAllCircles(){
            circles=[]; selectedCircle=null; selectedInfoElement.textContent='';
            playerKills=0; aiKills=0; playerKillsElement.textContent=playerKills; aiKillsElement.textContent=aiKills;
            gameStartTime=Date.now();
        }

        function setDifficulty(level){
            difficulty=level;
            for(const [key,btn] of Object.entries(difficultyButtons)){
                if(key===level) btn.classList.add('active-difficulty');
                else btn.classList.remove('active-difficulty');
            }
            for(const c of circles){
                if(c.team==='red'){
                    if(difficulty==='easy'){ c.speed=1.5; c.attackPower=8; }
                    else if(difficulty==='medium'){ c.speed=2; c.attackPower=10; }
                    else { c.speed=2.2; c.attackPower=12; }
                }
            }
        }

        function gameLoop(){
            ctx.clearRect(0,0,canvas.width,canvas.height);
            drawGrid();
            for(let i=0;i<circles.length;i++){
                const circle = circles[i];
                circle.move();

                // COLLISION RESOLUTION BETWEEN ALL CIRCLES
                for(let j=0;j<circles.length;j++){
                    if(i!==j){
                        const other = circles[j];
                        const dx = circle.x - other.x;
                        const dy = circle.y - other.y;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        const minDist = circle.radius + other.radius;
                        if(distance<minDist && distance>0){
                            const overlap = minDist - distance;
                            const nx = dx/distance; const ny = dy/distance;
                            circle.x += nx*(overlap/2); circle.y += ny*(overlap/2);
                            other.x -= nx*(overlap/2); other.y -= ny*(overlap/2);
                        }
                    }
                }

                // Attack enemies
                for(let j=0;j<circles.length;j++){
                    if(i!==j && circle.team!==circles[j].team && circle.isCollidingWith(circles[j])){
                        circle.attack(circles[j]);
                    }
                }

                circle.draw();
            }

            // Remove dead circles
            circles = circles.filter(c=>c.health>0);

            updateCircleCounts();
            requestAnimationFrame(gameLoop);
        }

        function drawGrid(){
            ctx.strokeStyle='rgba(255,255,255,0.05)'; ctx.lineWidth=1;
            for(let i=0;i<canvas.width;i+=50){ ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,canvas.height); ctx.stroke(); }
            for(let i=0;i<canvas.height;i+=50){ ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(canvas.width,i); ctx.stroke(); }
        }

        canvas.addEventListener('click',(e)=>{
            const rect=canvas.getBoundingClientRect();
            const mouseX=e.clientX-rect.left; const mouseY=e.clientY-rect.top;
            let clickedCircle=null;
            for(const c of circles){ if(c.team==='blue'){
                const dx=c.x-mouseX; const dy=c.y-mouseY;
                if(Math.sqrt(dx*dx+dy*dy)<=c.radius){ clickedCircle=c; break; }
            }}
            if(clickedCircle){ selectedCircle=clickedCircle; selectedInfoElement.textContent='Selected Circle'; }
            else if(selectedCircle){ selectedCircle.setTarget(mouseX,mouseY); }
        });

        spawnBlueButton.addEventListener('click',()=>spawnRandomCircle('blue'));
        spawnRedButton.addEventListener('click',()=>spawnRandomCircle('red'));
        clearAllButton.addEventListener('click',clearAllCircles);

        for(const [key,btn] of Object.entries(difficultyButtons)){ btn.addEventListener('click',()=>setDifficulty(key)); }

        init();
    </script>
</body>
</html>
